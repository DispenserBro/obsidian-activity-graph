[{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/locales/en.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/locales/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/locales/ru.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/localization.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1694,1697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1694,1697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2407,2410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2407,2410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Localization module - Internationalization support\n */\nimport Polyglot from 'node-polyglot';\nimport { App } from 'obsidian';\nimport { getLocale as getLocaleTranslations, isLocaleAvailable } from './locales/index';\nimport type { LocaleStrings } from './types/LocaleStrings';\nimport moment from 'moment';\n// Load all moment locales\nimport 'moment/min/locales';\n\n// Polyglot options interface\ninterface PolyglotOptions {\n    smart_count?: number;\n    [key: string]: string | number | boolean | undefined;\n}\n\n// Current locale and Polyglot instance\nlet currentLocale: string = 'en';\nlet polyglot: Polyglot | null = null;\nlet currentPhrases: LocaleStrings | null = null; // Store original phrases\n\n/**\n * Initialize locale from Obsidian settings\n */\nexport async function initLocale(app: App): Promise<string> {\n    // Get language from Obsidian's settings\n    interface VaultWithConfig {\n        config?: {\n            lang?: string;\n        };\n    }\n    const vault = app.vault as VaultWithConfig;\n    const obsidianLang = vault?.config?.lang || \n                         window.localStorage.getItem('language') || \n                         'en';\n    \n    // Extract base language code (e.g., 'ru' from 'ru-RU')\n    const baseLang = obsidianLang.split('-')[0].toLowerCase();\n    \n    // Set locale if available, otherwise fallback to English\n    currentLocale = isLocaleAvailable(baseLang) ? baseLang : 'en';\n    \n    // Get translations (synchronous now)\n    const phrases = getLocaleTranslations(currentLocale);\n    currentPhrases = phrases; // Store original object\n    \n    // Initialize Polyglot\n    polyglot = new Polyglot({\n        locale: currentLocale,\n        phrases: phrases as any // Polyglot expects Record<string, string>\n    });\n    \n    // Set moment.js locale\n    await setMomentLocale(baseLang);\n    \n    return currentLocale;\n}\n\n/**\n * Set moment.js locale\n */\nasync function setMomentLocale(locale: string): Promise<void> {\n    // All locales are already loaded via 'moment/min/locales'\n    // Just set the locale\n    moment.locale(locale);\n}\n\n/**\n * Get translation by key\n */\nexport function t(key: string, options: PolyglotOptions = {}): string | string[] {\n    if (!polyglot || !currentPhrases) {\n        console.warn('Polyglot not initialized yet, returning key');\n        return key;\n    }\n    \n    // Get the phrase from original object\n    const phrase = (currentPhrases as any)[key];\n    \n    // If phrase is undefined, return key\n    if (phrase === undefined) {\n        return key;\n    }\n    \n    // If phrase is an array, return it directly\n    if (Array.isArray(phrase)) {\n        return phrase;\n    }\n    \n    // Otherwise use polyglot's t() method for string interpolation\n    return polyglot.t(key, options);\n}\n\n/**\n * Get translation as string (safe version for UI elements that require string only)\n */\nexport function ts(key: string, options: PolyglotOptions = {}): string {\n    const result = t(key, options);\n    return Array.isArray(result) ? result.join(', ') : result;\n}\n\n/**\n * Get current locale\n */\nexport function getLocale(): string {\n    return currentLocale;\n}\n\n/**\n * Get month name (full)\n */\nexport function getMonthFull(monthIndex: number): string {\n    const months = t('monthsFull') as string[];\n    return months[monthIndex];\n}\n\n/**\n * Get month name (short)\n */\nexport function getMonthShort(monthIndex: number): string {\n    const months = t('monthsShort') as string[];\n    return months[monthIndex];\n}\n\n/**\n * Get day names (short)\n */\nexport function getDaysShort(firstDayOfWeek: 0 | 1 = 0): string[] {\n    const days = [...(t('daysShort') as string[])];\n    if (firstDayOfWeek === 1) {\n        // Move Sunday to the end for Monday start\n        const sunday = days.shift();\n        if (sunday) days.push(sunday);\n    }\n    return days;\n}\n\n/**\n * Get day labels for commit graph\n */\nexport function getDayLabels(firstDayOfWeek: 0 | 1 = 0): string[] {\n    const days = [...(t('daysShort') as string[])];\n    if (firstDayOfWeek === 1) {\n        // Move Sunday to the end for Monday start\n        const sunday = days.shift();\n        if (sunday) days.push(sunday);\n    }\n    // Return Mon, Wed, Fri labels (indices 1, 3, 5 for Sunday start or 0, 2, 4 for Monday start)\n    if (firstDayOfWeek === 1) {\n        return [days[0], days[2], days[4]]; // Mon, Wed, Fri\n    }\n    return [days[1], days[3], days[5]]; // Mon, Wed, Fri\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/processors/code-block-processor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2343,2346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2343,2346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2429,2432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2429,2432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Code Block Processor - Renders activity graph in notes\n */\nimport { getDateRange } from '../utils';\nimport { CommitGraphRenderer, CalendarRenderer } from '../renderers/index';\nimport type { ActivityGraphPlugin, CodeBlockOptions, ActivityGraphSettings } from '../types';\n\nexport class CodeBlockProcessor {\n    private plugin: ActivityGraphPlugin;\n\n    constructor(plugin: ActivityGraphPlugin) {\n        this.plugin = plugin;\n    }\n\n    register(): void {\n        this.plugin.registerMarkdownCodeBlockProcessor(\n            'activity-graph',\n            async (source, el, ctx) => {\n                await this.processCodeBlock(source, el);\n            }\n        );\n    }\n\n    parseOptions(source: string): CodeBlockOptions {\n        const options: CodeBlockOptions = {};\n        const lines = source.trim().split('\\n');\n        \n        for (const line of lines) {\n            const colonIndex = line.indexOf(':');\n            if (colonIndex === -1) continue;\n            \n            const key = line.substring(0, colonIndex).trim() as keyof CodeBlockOptions;\n            const value = line.substring(colonIndex + 1).trim();\n            \n            if (key && value) {\n                // Parse array values like [#color1, #color2, ...]\n                if (value.startsWith('[') && value.endsWith(']')) {\n                    const arrayContent = value.slice(1, -1);\n                    // Remove quotes from array values and trim whitespace\n                    const arrayValue = arrayContent.split(',').map(s => s.trim().replace(/^[\"']|[\"']$/g, ''));\n                    if (key === 'colors' || key === 'lightColors' || key === 'darkColors' || \n                        key === 'textColors' || key === 'lightTextColors' || key === 'darkTextColors') {\n                        options[key] = arrayValue;\n                    }\n                } else {\n                    (options as Record<string, string>)[key] = value;\n                }\n            }\n        }\n        \n        return options;\n    }\n\n    async processCodeBlock(source: string, el: HTMLElement): Promise<void> {\n        const options = this.parseOptions(source);\n        \n        // Create merged settings with options overriding defaults\n        const settings: ActivityGraphSettings = {\n            ...this.plugin.settings,\n            displayPeriod: options.period as any || this.plugin.settings.displayPeriod,\n            displayStyle: options.style as any || this.plugin.settings.displayStyle,\n            displayOnlyTasks: options.tasks === 'true' || \n                (options.tasks !== 'false' && this.plugin.settings.displayOnlyTasks),\n            // Deep copy color schemes to avoid mutating original\n            lightTheme: { ...this.plugin.settings.lightTheme },\n            darkTheme: { ...this.plugin.settings.darkTheme }\n        };\n\n        // Handle highlight today option\n        if (options.highlightToday !== undefined) {\n            settings.highlightToday = options.highlightToday === 'true';\n        }\n\n        // Handle custom colors array (apply to both themes)\n        if (options.colors && Array.isArray(options.colors) && options.colors.length === 5) {\n            settings.lightTheme.level0 = options.colors[0];\n            settings.lightTheme.level1 = options.colors[1];\n            settings.lightTheme.level2 = options.colors[2];\n            settings.lightTheme.level3 = options.colors[3];\n            settings.lightTheme.level4 = options.colors[4];\n            settings.darkTheme.level0 = options.colors[0];\n            settings.darkTheme.level1 = options.colors[1];\n            settings.darkTheme.level2 = options.colors[2];\n            settings.darkTheme.level3 = options.colors[3];\n            settings.darkTheme.level4 = options.colors[4];\n        }\n\n        // Handle custom text colors array (apply to both themes)\n        if (options.textColors && Array.isArray(options.textColors) && options.textColors.length === 5) {\n            settings.lightTheme.textLevel0 = options.textColors[0];\n            settings.lightTheme.textLevel1 = options.textColors[1];\n            settings.lightTheme.textLevel2 = options.textColors[2];\n            settings.lightTheme.textLevel3 = options.textColors[3];\n            settings.lightTheme.textLevel4 = options.textColors[4];\n            settings.darkTheme.textLevel0 = options.textColors[0];\n            settings.darkTheme.textLevel1 = options.textColors[1];\n            settings.darkTheme.textLevel2 = options.textColors[2];\n            settings.darkTheme.textLevel3 = options.textColors[3];\n            settings.darkTheme.textLevel4 = options.textColors[4];\n        }\n\n        // Handle separate light/dark theme colors\n        if (options.lightColors && Array.isArray(options.lightColors) && options.lightColors.length === 5) {\n            settings.lightTheme.level0 = options.lightColors[0];\n            settings.lightTheme.level1 = options.lightColors[1];\n            settings.lightTheme.level2 = options.lightColors[2];\n            settings.lightTheme.level3 = options.lightColors[3];\n            settings.lightTheme.level4 = options.lightColors[4];\n        }\n        if (options.darkColors && Array.isArray(options.darkColors) && options.darkColors.length === 5) {\n            settings.darkTheme.level0 = options.darkColors[0];\n            settings.darkTheme.level1 = options.darkColors[1];\n            settings.darkTheme.level2 = options.darkColors[2];\n            settings.darkTheme.level3 = options.darkColors[3];\n            settings.darkTheme.level4 = options.darkColors[4];\n        }\n\n        // Handle separate light/dark theme text colors\n        if (options.lightTextColors && Array.isArray(options.lightTextColors) && options.lightTextColors.length === 5) {\n            settings.lightTheme.textLevel0 = options.lightTextColors[0];\n            settings.lightTheme.textLevel1 = options.lightTextColors[1];\n            settings.lightTheme.textLevel2 = options.lightTextColors[2];\n            settings.lightTheme.textLevel3 = options.lightTextColors[3];\n            settings.lightTheme.textLevel4 = options.lightTextColors[4];\n        }\n        if (options.darkTextColors && Array.isArray(options.darkTextColors) && options.darkTextColors.length === 5) {\n            settings.darkTheme.textLevel0 = options.darkTextColors[0];\n            settings.darkTheme.textLevel1 = options.darkTextColors[1];\n            settings.darkTheme.textLevel2 = options.darkTextColors[2];\n            settings.darkTheme.textLevel3 = options.darkTextColors[3];\n            settings.darkTheme.textLevel4 = options.darkTextColors[4];\n        }\n\n        // Handle custom dates from options\n        if (options.start) {\n            settings.displayPeriod = 'custom';\n            settings.customStartDate = options.start;\n        }\n        if (options.end) {\n            settings.displayPeriod = 'custom';\n            settings.customEndDate = options.end;\n        }\n\n        // Create container\n        el.addClass('activity-graph-container');\n        el.addClass('activity-graph-embed');\n        \n        // Apply custom colors to the container (parent element)\n        this.applyCustomColors(el, settings);\n\n        // Render title if provided\n        if (options.title) {\n            const header = el.createEl('div', { cls: 'activity-graph-header' });\n            header.createEl('h4', { text: options.title });\n        }\n\n        const graphContainer = el.createEl('div', { cls: 'activity-graph' });\n\n        // Load data\n        let activityData;\n        if (settings.displayOnlyTasks && this.plugin.isTasksPluginEnabled()) {\n            await this.plugin.loadTasksData();\n            activityData = this.plugin.tasksData;\n        } else {\n            activityData = this.plugin.activityData;\n        }\n\n        const { startDate, endDate } = getDateRange(settings);\n\n        // Create renderer with custom settings\n        // Code blocks use compact mode for calendar (single month with navigation)\n        // IMPORTANT: calendar-sheet is only for sidebar view, in code blocks it uses calendar\n        let renderer;\n        if (settings.displayStyle === 'calendar' || settings.displayStyle === 'calendar-sheet') {\n            renderer = new CalendarRenderer(this.plugin, settings, true); // compactMode = true\n        } else {\n            renderer = new CommitGraphRenderer(this.plugin, settings);\n        }\n\n        // Render graph\n        renderer.render(graphContainer, activityData, startDate, endDate);\n    }\n\n    private applyCustomColors(container: HTMLElement, settings: ActivityGraphSettings): void {\n        container.style.setProperty('--activity-light-level-0', settings.lightTheme.level0);\n        container.style.setProperty('--activity-light-level-1', settings.lightTheme.level1);\n        container.style.setProperty('--activity-light-level-2', settings.lightTheme.level2);\n        container.style.setProperty('--activity-light-level-3', settings.lightTheme.level3);\n        container.style.setProperty('--activity-light-level-4', settings.lightTheme.level4);\n        container.style.setProperty('--activity-dark-level-0', settings.darkTheme.level0);\n        container.style.setProperty('--activity-dark-level-1', settings.darkTheme.level1);\n        container.style.setProperty('--activity-dark-level-2', settings.darkTheme.level2);\n        container.style.setProperty('--activity-dark-level-3', settings.darkTheme.level3);\n        container.style.setProperty('--activity-dark-level-4', settings.darkTheme.level4);\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/renderers/base-renderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'App' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TFile' is defined but never used.","line":4,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'moment' is defined but never used.","line":4,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getDailyNotesSettings' is defined but never used.","line":5,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatDailyNoteFilename' is defined but never used.","line":5,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":68}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Base Renderer - Common functionality for graph renderers\n */\nimport { App, TFile, moment } from 'obsidian';\nimport { formatDate, getDailyNotesSettings, formatDailyNoteFilename } from '../utils';\nimport { t, ts } from '../localization';\nimport { ActivityGraphSettings, ActivityGraphPlugin } from '../types';\nimport { createDailyNote, getAllDailyNotes, getDailyNote } from 'obsidian-daily-notes-interface';\n\nexport class BaseRenderer {\n    plugin: ActivityGraphPlugin | null;\n    customSettings: Partial<ActivityGraphSettings> | null;\n    todayStr: string;\n    currentTooltip: HTMLElement | null;\n    private tooltipHideTimer: number | null;\n\n    constructor(plugin: ActivityGraphPlugin | null = null, customSettings: Partial<ActivityGraphSettings> | null = null) {\n        this.currentTooltip = null;\n        this.tooltipHideTimer = null;\n        this.plugin = plugin;\n        this.customSettings = customSettings;\n        this.todayStr = formatDate(new Date());\n    }\n\n    setPlugin(plugin: ActivityGraphPlugin): void {\n        this.plugin = plugin;\n    }\n\n    setCustomSettings(settings: Partial<ActivityGraphSettings>): void {\n        this.customSettings = settings;\n    }\n\n    getSettings(): Partial<ActivityGraphSettings> {\n        return this.customSettings || (this.plugin && this.plugin.settings) || {};\n    }\n\n    isToday(dateStr) {\n        return dateStr === this.todayStr;\n    }\n\n    shouldHighlightToday() {\n        const settings = this.getSettings();\n        return settings.highlightToday !== undefined ? settings.highlightToday : false;\n    }\n\n    getHighlightColor() {\n        const settings = this.getSettings();\n        return settings.highlightColor || '#7c3aed';\n    }\n\n    getFirstDayOfWeek() {\n        const settings = this.getSettings();\n        return settings.firstDayOfWeek !== undefined ? settings.firstDayOfWeek : 0;\n    }\n\n    showTooltip(element: HTMLElement, date: string, count: number): void {\n        // Clear any pending hide timer\n        if (this.tooltipHideTimer !== null) {\n            window.clearTimeout(this.tooltipHideTimer);\n            this.tooltipHideTimer = null;\n        }\n        \n        // Hide any existing tooltip first\n        this.hideTooltip();\n        \n        const tooltip = document.createElement('div');\n        tooltip.addClass('activity-tooltip');\n        tooltip.textContent = `${count} ${t('tooltipActivities')} ${date}`;\n        \n        const rect = element.getBoundingClientRect();\n        tooltip.style.left = rect.left + 'px';\n        tooltip.style.top = (rect.top - 30) + 'px';\n        \n        document.body.appendChild(tooltip);\n        this.currentTooltip = tooltip;\n    }\n\n    hideTooltip(): void {\n        // Clear any pending hide timer\n        if (this.tooltipHideTimer !== null) {\n            window.clearTimeout(this.tooltipHideTimer);\n            this.tooltipHideTimer = null;\n        }\n        \n        if (this.currentTooltip) {\n            this.currentTooltip.remove();\n            this.currentTooltip = null;\n        }\n    }\n    \n    scheduleHideTooltip(delay = 100): void {\n        // Clear existing timer\n        if (this.tooltipHideTimer !== null) {\n            window.clearTimeout(this.tooltipHideTimer);\n        }\n        \n        // Schedule hide\n        this.tooltipHideTimer = window.setTimeout(() => {\n            this.hideTooltip();\n            this.tooltipHideTimer = null;\n        }, delay);\n    }\n    \n    addGlobalTooltipHandlers(): void {\n        // Hide tooltip on scroll\n        const onScroll = () => this.hideTooltip();\n        document.addEventListener('scroll', onScroll, { passive: true, capture: true });\n        \n        // Hide tooltip on click outside\n        const onClick = (e: MouseEvent) => {\n            if (this.currentTooltip && !this.currentTooltip.contains(e.target as Node)) {\n                this.hideTooltip();\n            }\n        };\n        document.addEventListener('click', onClick, { capture: true });\n        \n        // Store handlers for cleanup\n        if (!this.plugin) return;\n        \n        // We'll clean up these handlers when the renderer is destroyed\n        this.plugin.register(() => {\n            document.removeEventListener('scroll', onScroll, { capture: true });\n            document.removeEventListener('click', onClick, { capture: true });\n        });\n    }\n\n    renderLegend(container: HTMLElement, additionalClass = ''): void {\n        const cls = additionalClass ? `graph-legend ${additionalClass}` : 'graph-legend';\n        const legend = container.createEl('div', { cls });\n        legend.createEl('span', { text: ts('legendLess'), cls: 'legend-text' });\n        for (let i = 0; i <= 4; i++) {\n            legend.createEl('div', { cls: `graph-square level-${i}` });\n        }\n        legend.createEl('span', { text: ts('legendMore'), cls: 'legend-text' });\n    }\n\n    addTooltipListeners(element: HTMLElement, dateStr: string, count: number): void {\n        element.addEventListener('mouseenter', (e) => {\n            this.showTooltip(e.target as HTMLElement, dateStr, count);\n        });\n        \n        element.addEventListener('mouseleave', () => {\n            // Use delayed hide to prevent flickering\n            this.scheduleHideTooltip(100);\n        });\n        \n        // Hide tooltip when element is clicked\n        element.addEventListener('click', () => {\n            this.hideTooltip();\n            this.openDailyNote(dateStr);\n        });\n    }\n\n    /**\n     * Open daily note for the given date\n     * Uses the Daily Notes plugin settings for path and format\n     */\n    async openDailyNote(dateStr: string): Promise<void> {\n        if (!this.plugin) return;\n\n        const app = this.plugin.app;\n        \n        // Parse the date\n        const date = window.moment(dateStr);\n        \n        // Get all daily notes\n        const dailyNotes = getAllDailyNotes();\n        \n        // Check if daily note exists\n        let file = getDailyNote(date, dailyNotes);\n        \n        if (!file) {\n            // Create new daily note using Daily Notes API (this will apply templates)\n            file = await createDailyNote(date);\n        }\n        \n        // Open the file\n        if (file) {\n            const leaf = app.workspace.getLeaf(false);\n            await leaf.openFile(file);\n        }\n    }\n\n    /**\n     * Clean up resources (remove tooltips)\n     */\n    cleanup(): void {\n        this.hideTooltip();\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/renderers/calendar-renderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CalendarDate' is defined but never used.","line":7,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Calendar Renderer - Monthly calendar view with optional navigation\n */\nimport { BaseRenderer } from './base-renderer';\nimport { formatDate, getActivityLevel, getMonthsInRange } from '../utils';\nimport { getMonthFull, getDaysShort, ts } from '../localization';\nimport type { ActivityData, CalendarDate, ActivityGraphPlugin } from '../types';\nimport type { ActivityGraphSettings } from '../types';\n\nexport class CalendarRenderer extends BaseRenderer {\n    private compactMode: boolean;\n    private months!: Date[];\n    private currentMonthIndex!: number;\n    private activityData!: ActivityData;\n    private startDate!: Date;\n    private endDate!: Date;\n    private container!: HTMLElement;\n    private calendarContainer!: HTMLElement;\n\n    constructor(plugin: ActivityGraphPlugin | null = null, customSettings: Partial<ActivityGraphSettings> | null = null, compactMode: boolean = false) {\n        super(plugin, customSettings);\n        this.compactMode = compactMode; // true = single month with navigation, false = all months\n    }\n\n    render(container: HTMLElement, activityData: ActivityData, startDate: Date, endDate: Date): void {\n        this.months = getMonthsInRange(startDate, endDate);\n        this.currentMonthIndex = this.months.length - 1; // Start with most recent month\n        this.activityData = activityData;\n        this.startDate = startDate;\n        this.endDate = endDate;\n        this.container = container;\n        \n        // Add custom color styles if customSettings exist\n        if (this.customSettings && this.customSettings.lightTheme && this.customSettings.darkTheme) {\n            container.addClass('custom-colors');\n            const uniqueId = `calendar-custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            container.setAttribute('data-style-id', uniqueId);\n            \n            const styleEl = document.createElement('style');\n            styleEl.id = `style-${uniqueId}`;\n            const light = this.customSettings.lightTheme;\n            const dark = this.customSettings.darkTheme;\n            \n            let styles = '';\n            \n            // Background colors\n            for (let i = 0; i <= 4; i++) {\n                const bgColor = light[`level${i}` as keyof typeof light];\n                if (bgColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-light .calendar-day.level-${i},\n                .theme-light [data-style-id=\"${uniqueId}\"] .calendar-day.level-${i} { background-color: ${bgColor} !important; }`;\n                }\n            }\n            for (let i = 0; i <= 4; i++) {\n                const bgColor = dark[`level${i}` as keyof typeof dark];\n                if (bgColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-dark .calendar-day.level-${i},\n                .theme-dark [data-style-id=\"${uniqueId}\"] .calendar-day.level-${i} { background-color: ${bgColor} !important; }`;\n                }\n            }\n            \n            // Text colors\n            for (let i = 0; i <= 4; i++) {\n                const textColor = light[`textLevel${i}` as keyof typeof light];\n                if (textColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-light .calendar-day.level-${i},\n                .theme-light [data-style-id=\"${uniqueId}\"] .calendar-day.level-${i} { color: ${textColor} !important; }`;\n                }\n            }\n            for (let i = 0; i <= 4; i++) {\n                const textColor = dark[`textLevel${i}` as keyof typeof dark];\n                if (textColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-dark .calendar-day.level-${i},\n                .theme-dark [data-style-id=\"${uniqueId}\"] .calendar-day.level-${i} { color: ${textColor} !important; }`;\n                }\n            }\n            \n            styleEl.textContent = styles;\n            document.head.appendChild(styleEl);\n        }\n        \n        // Add global handlers to hide tooltip on scroll/outside click\n        this.addGlobalTooltipHandlers();\n        \n        this.calendarContainer = container.createEl('div', { cls: 'calendar-container' });\n        \n        if (this.compactMode) {\n            this.renderCurrentMonth();\n        } else {\n            this.renderAllMonths();\n        }\n        \n        this.renderLegend(container, 'calendar-legend');\n    }\n\n    renderAllMonths(): void {\n        this.calendarContainer.empty();\n        \n        for (const monthDate of this.months) {\n            this.renderMonthCard(this.calendarContainer, monthDate, false);\n        }\n    }\n\n    renderCurrentMonth(): void {\n        this.calendarContainer.empty();\n        \n        const monthDate = this.months[this.currentMonthIndex];\n        const showNavigation = this.months.length > 1;\n        \n        this.renderMonthCard(this.calendarContainer, monthDate, showNavigation);\n    }\n\n    renderMonthCard(container: HTMLElement, monthDate: Date, showNavigation: boolean): void {\n        const year = monthDate.getFullYear();\n        const month = monthDate.getMonth();\n        \n        const monthCard = container.createEl('div', { cls: 'calendar-month-card' });\n        \n        const monthHeader = monthCard.createEl('div', { cls: 'calendar-month-header' });\n        \n        if (showNavigation) {\n            // Left arrow\n            const leftArrow = monthHeader.createEl('button', { \n                cls: 'calendar-nav-btn calendar-nav-prev',\n                attr: { 'aria-label': ts('navPrevMonth') }\n            });\n            leftArrow.innerHTML = '‹';\n            leftArrow.disabled = this.currentMonthIndex === 0;\n            leftArrow.addEventListener('click', () => this.navigateMonth(-1));\n        }\n        \n        monthHeader.createEl('span', { \n            text: `${getMonthFull(month)} ${year}`,\n            cls: 'calendar-month-title'\n        });\n        \n        if (showNavigation) {\n            // Right arrow\n            const rightArrow = monthHeader.createEl('button', { \n                cls: 'calendar-nav-btn calendar-nav-next',\n                attr: { 'aria-label': ts('navNextMonth') }\n            });\n            rightArrow.innerHTML = '›';\n            rightArrow.disabled = this.currentMonthIndex === this.months.length - 1;\n            rightArrow.addEventListener('click', () => this.navigateMonth(1));\n        }\n        \n        this.renderDayNamesRow(monthCard);\n        \n        const calendarGrid = monthCard.createEl('div', { cls: 'calendar-grid' });\n        \n        const firstDayOfMonth = new Date(year, month, 1);\n        const lastDayOfMonth = new Date(year, month + 1, 0);\n        const firstDayWeekday = firstDayOfMonth.getDay();\n        const totalDays = lastDayOfMonth.getDate();\n        \n        // Calculate empty cells based on first day of week setting\n        const firstDayOfWeek = this.getFirstDayOfWeek();\n        const emptyCells = (firstDayWeekday - firstDayOfWeek + 7) % 7;\n        \n        for (let i = 0; i < emptyCells; i++) {\n            calendarGrid.createEl('div', { cls: 'calendar-day empty' });\n        }\n        \n        for (let day = 1; day <= totalDays; day++) {\n            this.renderDayCell(calendarGrid, year, month, day);\n        }\n    }\n\n    navigateMonth(direction: number): void {\n        const newIndex = this.currentMonthIndex + direction;\n        if (newIndex >= 0 && newIndex < this.months.length) {\n            this.currentMonthIndex = newIndex;\n            this.renderCurrentMonth();\n        }\n    }\n\n    renderDayNamesRow(monthCard: HTMLElement): void {\n        const dayNamesRow = monthCard.createEl('div', { cls: 'calendar-day-names' });\n        const firstDay = this.getFirstDayOfWeek();\n        getDaysShort(firstDay).forEach(day => {\n            dayNamesRow.createEl('span', { text: day, cls: 'calendar-day-name' });\n        });\n    }\n\n    renderDayCell(calendarGrid: HTMLElement, year: number, month: number, day: number): void {\n        const date = new Date(year, month, day);\n        const dateStr = formatDate(date);\n        const isInRange = date >= this.startDate && date <= this.endDate;\n        \n        if (isInRange) {\n            const count = this.activityData[dateStr] || 0;\n            const level = getActivityLevel(count);\n            \n            let dayClass = `calendar-day level-${level}`;\n            if (this.shouldHighlightToday() && this.isToday(dateStr)) {\n                dayClass += ' today';\n            }\n            \n            const dayCell = calendarGrid.createEl('div', { \n                cls: dayClass,\n                text: day.toString()\n            });\n            \n            // Apply custom highlight color\n            if (this.shouldHighlightToday() && this.isToday(dateStr)) {\n                dayCell.style.outlineColor = this.getHighlightColor();\n            }\n            \n            dayCell.setAttribute('data-date', dateStr);\n            dayCell.setAttribute('data-count', String(count));\n            \n            this.addTooltipListeners(dayCell, dateStr, count);\n        } else {\n            calendarGrid.createEl('div', { \n                cls: 'calendar-day out-of-range',\n                text: day.toString()\n            });\n        }\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/renderers/calendar-sheet-renderer.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'offset' is never reassigned. Use 'const' instead.","line":191,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":191,"endColumn":19,"fix":{"range":[7576,7626],"text":"const offset = (firstDayOfMonth - firstDay + 7) % 7;"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Calendar Sheet Renderer - Single month calendar view similar to obsidian-calendar-plugin\n * Shows one month at a time with navigation arrows\n */\nimport { BaseRenderer } from './base-renderer';\nimport { formatDate, getMonthsInRange } from '../utils';\nimport { getMonthFull, getDaysShort, ts } from '../localization';\nimport type { ActivityData, TasksStatusData, ActivityDotPosition } from '../types';\n\nexport class CalendarSheetRenderer extends BaseRenderer {\n    private months: Date[] = [];\n    private currentMonthIndex: number = 0;\n    private activityData: ActivityData = {};\n    private tasksStatusData: TasksStatusData = {};\n    private dotPosition: ActivityDotPosition = 'center';\n    private startDate!: Date;\n    private endDate!: Date;\n    private container!: HTMLElement;\n    private sheetContainer!: HTMLElement;\n\n    render(\n        container: HTMLElement, \n        activityData: ActivityData, \n        startDate: Date, \n        endDate: Date,\n        tasksStatusData: TasksStatusData = {},\n        dotPosition: ActivityDotPosition = 'center'\n    ): void {\n        this.months = getMonthsInRange(startDate, endDate);\n        this.currentMonthIndex = this.months.length - 1; // Start with most recent month\n        this.activityData = activityData;\n        this.tasksStatusData = tasksStatusData;\n        this.dotPosition = dotPosition;\n        this.startDate = startDate;\n        this.endDate = endDate;\n        this.container = container;\n\n        // Add custom color styles if customSettings exist\n        if (this.customSettings && this.customSettings.lightTheme && this.customSettings.darkTheme) {\n            container.addClass('custom-colors');\n            const uniqueId = `calendar-sheet-custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            container.setAttribute('data-style-id', uniqueId);\n            \n            const styleEl = document.createElement('style');\n            styleEl.id = `style-${uniqueId}`;\n            const light = this.customSettings.lightTheme;\n            const dark = this.customSettings.darkTheme;\n            \n            let styles = '';\n            \n            // Background colors for dots\n            for (let i = 0; i <= 4; i++) {\n                const bgColor = light[`level${i}` as keyof typeof light];\n                if (bgColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-light .calendar-sheet-dot.level-${i},\n                .theme-light [data-style-id=\"${uniqueId}\"] .calendar-sheet-dot.level-${i} { background-color: ${bgColor} !important; }`;\n                }\n            }\n            for (let i = 0; i <= 4; i++) {\n                const bgColor = dark[`level${i}` as keyof typeof dark];\n                if (bgColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-dark .calendar-sheet-dot.level-${i},\n                .theme-dark [data-style-id=\"${uniqueId}\"] .calendar-sheet-dot.level-${i} { background-color: ${bgColor} !important; }`;\n                }\n            }\n            \n            // Text colors for day numbers\n            for (let i = 0; i <= 4; i++) {\n                const textColor = light[`textLevel${i}` as keyof typeof light];\n                if (textColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-light .calendar-sheet-day.has-activity.level-${i} .calendar-sheet-day-number,\n                .theme-light [data-style-id=\"${uniqueId}\"] .calendar-sheet-day.has-activity.level-${i} .calendar-sheet-day-number { color: ${textColor} !important; }`;\n                }\n            }\n            for (let i = 0; i <= 4; i++) {\n                const textColor = dark[`textLevel${i}` as keyof typeof dark];\n                if (textColor) {\n                    styles += `\n                [data-style-id=\"${uniqueId}\"] .theme-dark .calendar-sheet-day.has-activity.level-${i} .calendar-sheet-day-number,\n                .theme-dark [data-style-id=\"${uniqueId}\"] .calendar-sheet-day.has-activity.level-${i} .calendar-sheet-day-number { color: ${textColor} !important; }`;\n                }\n            }\n            \n            styleEl.textContent = styles;\n            document.head.appendChild(styleEl);\n        }\n\n        // Add global handlers to hide tooltip\n        this.addGlobalTooltipHandlers();\n\n        this.sheetContainer = container.createEl('div', { cls: 'calendar-sheet-container' });\n        \n        this.renderCurrentMonth();\n    }\n\n    private renderCurrentMonth(): void {\n        this.sheetContainer.empty();\n\n        const monthDate = this.months[this.currentMonthIndex];\n        \n        // Navigation header\n        if (this.months.length > 1) {\n            this.renderNavigation();\n        }\n\n        // Month card\n        this.renderMonthCard(this.sheetContainer, monthDate);\n    }\n\n    private renderNavigation(): void {\n        const nav = this.sheetContainer.createEl('div', { cls: 'calendar-sheet-nav' });\n\n        // Previous month button\n        const prevBtn = nav.createEl('button', { \n            cls: 'calendar-sheet-nav-btn',\n            attr: { 'aria-label': ts('navPrevMonth') }\n        });\n        prevBtn.innerHTML = '‹';\n        prevBtn.addEventListener('click', () => this.navigateMonth(-1));\n        \n        if (this.currentMonthIndex <= 0) {\n            prevBtn.addClass('disabled');\n        }\n\n        // Current month title\n        const monthDate = this.months[this.currentMonthIndex];\n        nav.createEl('div', { \n            text: `${getMonthFull(monthDate.getMonth())} ${monthDate.getFullYear()}`,\n            cls: 'calendar-sheet-nav-title'\n        });\n\n        // Next month button\n        const nextBtn = nav.createEl('button', { \n            cls: 'calendar-sheet-nav-btn',\n            attr: { 'aria-label': ts('navNextMonth') }\n        });\n        nextBtn.innerHTML = '›';\n        nextBtn.addEventListener('click', () => this.navigateMonth(1));\n        \n        if (this.currentMonthIndex >= this.months.length - 1) {\n            nextBtn.addClass('disabled');\n        }\n    }\n\n    private navigateMonth(direction: number): void {\n        const newIndex = this.currentMonthIndex + direction;\n        if (newIndex >= 0 && newIndex < this.months.length) {\n            this.currentMonthIndex = newIndex;\n            this.renderCurrentMonth();\n        }\n    }\n\n    private renderMonthCard(container: HTMLElement, monthDate: Date): void {\n        const monthCard = container.createEl('div', { cls: 'calendar-sheet-month' });\n\n        // Calendar grid\n        const grid = monthCard.createEl('div', { cls: 'calendar-sheet-grid' });\n\n        // Day headers\n        this.renderDayHeaders(grid);\n\n        // Calendar days\n        this.renderDays(grid, monthDate);\n    }\n\n    private renderDayHeaders(grid: HTMLElement): void {\n        const firstDay = this.getFirstDayOfWeek();\n        const daysShort = getDaysShort();\n\n        for (let i = 0; i < 7; i++) {\n            const dayIndex = (firstDay + i) % 7;\n            grid.createEl('div', { \n                text: daysShort[dayIndex],\n                cls: 'calendar-sheet-day-header'\n            });\n        }\n    }\n\n    private renderDays(grid: HTMLElement, monthDate: Date): void {\n        const firstDay = this.getFirstDayOfWeek();\n        const year = monthDate.getFullYear();\n        const month = monthDate.getMonth();\n        const date = new Date(year, month, 1);\n        const firstDayOfMonth = date.getDay();\n        const daysInMonth = new Date(year, month + 1, 0).getDate();\n\n        // Calculate offset for first day\n        let offset = (firstDayOfMonth - firstDay + 7) % 7;\n\n        // Empty cells before month starts\n        for (let i = 0; i < offset; i++) {\n            grid.createEl('div', { cls: 'calendar-sheet-day empty' });\n        }\n\n        // Days of the month\n        for (let day = 1; day <= daysInMonth; day++) {\n            const currentDate = new Date(year, month, day);\n            const dateStr = formatDate(currentDate);\n            const count = this.activityData[dateStr] || 0;\n            const taskStatus = this.tasksStatusData[dateStr];\n            const level = this.getActivityLevel(count);\n            \n            const dayCell = grid.createEl('div', { cls: 'calendar-sheet-day' });\n            \n            // Add activity level class if there's activity\n            if (count > 0) {\n                dayCell.addClass('has-activity');\n                dayCell.addClass(`level-${level}`);\n            }\n\n            // Date number\n            const dayNumber = dayCell.createEl('div', { \n                text: String(day),\n                cls: 'calendar-sheet-day-number'\n            });\n\n            // Task status indicators (dots below date)\n            if (taskStatus) {\n                const dotsContainer = dayCell.createEl('div', { cls: 'calendar-sheet-task-dots' });\n                \n                if (taskStatus.hasIncompleteTasks) {\n                    // Show both filled and empty dots\n                    dotsContainer.createEl('div', { cls: 'calendar-sheet-task-dot filled' });\n                    dotsContainer.createEl('div', { cls: 'calendar-sheet-task-dot empty' });\n                } else if (taskStatus.hasCompletedTasks) {\n                    // Show only filled dot\n                    dotsContainer.createEl('div', { cls: 'calendar-sheet-task-dot filled' });\n                }\n            }\n\n            // Activity indicator (dot)\n            if (count > 0) {\n                const dot = dayCell.createEl('div', { cls: 'calendar-sheet-dot' });\n                \n                // Set color based on activity level\n                dot.addClass(`level-${level}`);\n                \n                // Add position class\n                dot.addClass(`position-${this.dotPosition}`);\n                \n                // For center position and higher activity levels (3-4), make text darker for better contrast\n                if (this.dotPosition === 'center' && level >= 3) {\n                    dayNumber.addClass('dark-text');\n                }\n            }\n\n            // Highlight today\n            if (this.shouldHighlightToday() && dateStr === this.todayStr) {\n                dayCell.addClass('today');\n                const highlightColor = this.getHighlightColor();\n                dayCell.style.setProperty('--highlight-color', highlightColor);\n            }\n\n            // Check if date is in range\n            if (currentDate < this.startDate || currentDate > this.endDate) {\n                dayCell.addClass('out-of-range');\n            }\n\n            // Add tooltip and click listeners\n            this.addTooltipListeners(dayCell, dateStr, count);\n        }\n    }\n\n    private getActivityLevel(count: number): number {\n        if (count === 0) return 0;\n        if (count <= 2) return 1;\n        if (count <= 5) return 2;\n        if (count <= 10) return 3;\n        return 4;\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/renderers/commit-graph-renderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/renderers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/settings/settings-tab.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'t' is defined but never used.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5214,5217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5214,5217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings Tab - Plugin configuration UI\n */\nimport { PluginSettingTab, App, Setting } from 'obsidian';\nimport { t, ts } from '../localization';\nimport { getDailyNotePath } from '../utils';\nimport type { ActivityGraphPlugin } from '../types';\n\nexport class ActivityGraphSettingTab extends PluginSettingTab {\n    private plugin: ActivityGraphPlugin;\n    private pathPreviewSpan: HTMLSpanElement | null = null;\n    private formatPreviewSpan: HTMLSpanElement | null = null;\n    private updatePathPreviewDebounce: number | null = null;\n    private updateFormatPreviewDebounce: number | null = null;\n\n    constructor(app: App, plugin: ActivityGraphPlugin) {\n        super(app, plugin);\n        this.plugin = plugin;\n    }\n    \n    private async updatePathPreview(): Promise<void> {\n        if (this.pathPreviewSpan) {\n            const previewPath = await getDailyNotePath(this.app, this.plugin.settings);\n            this.pathPreviewSpan.setText(previewPath);\n        }\n    }\n    \n    private async updateFormatPreview(): Promise<void> {\n        if (this.formatPreviewSpan) {\n            const previewPath = await getDailyNotePath(this.app, this.plugin.settings);\n            this.formatPreviewSpan.setText(previewPath);\n        }\n    }\n\n    async display() {\n        const { containerEl } = this;\n        containerEl.empty();\n\n        containerEl.createEl('h2', { text: ts('settingsTitle') });\n\n        // Highlight Today Setting\n        new Setting(containerEl)\n            .setName(ts('settingHighlightToday'))\n            .setDesc(ts('settingHighlightTodayDesc'))\n            .addToggle(toggle => toggle\n                .setValue(this.plugin.settings.highlightToday)\n                .onChange(async (value) => {\n                    this.plugin.settings.highlightToday = value;\n                    await this.plugin.saveSettings();\n                    this.display();\n                    this.plugin.updateView();\n                }));\n\n        // Highlight Color Setting (only shown when highlightToday is enabled)\n        if (this.plugin.settings.highlightToday) {\n            const colorSetting = new Setting(containerEl)\n                .setName(ts('settingHighlightColor'))\n                .setDesc(ts('settingHighlightColorDesc'));\n            \n            const colorInput = colorSetting.controlEl.createEl('input', {\n                type: 'color',\n                cls: 'activity-color-input'\n            });\n            colorInput.value = this.plugin.settings.highlightColor;\n            colorInput.addEventListener('change', async (e) => {\n                const target = e.target as HTMLInputElement;\n                this.plugin.settings.highlightColor = target.value;\n                await this.plugin.saveSettings();\n                this.plugin.updateView();\n            });\n        }\n\n        // Display Only Tasks Setting (only show if Tasks plugin is installed)\n        if (this.plugin.isTasksPluginEnabled()) {\n            new Setting(containerEl)\n                .setName(ts('settingDisplayOnlyTasks'))\n                .setDesc(ts('settingDisplayOnlyTasksDesc'))\n                .addToggle(toggle => toggle\n                    .setValue(this.plugin.settings.displayOnlyTasks)\n                    .onChange(async (value) => {\n                        this.plugin.settings.displayOnlyTasks = value;\n                        await this.plugin.saveSettings();\n                        this.plugin.updateView();\n                    }));\n        }\n\n        // Display Style Setting\n        new Setting(containerEl)\n            .setName(ts('settingDisplayStyle'))\n            .setDesc(ts('settingDisplayStyleDesc'))\n            .addDropdown(dropdown => dropdown\n                .addOption('commit-graph', ts('styleCommitGraph'))\n                .addOption('calendar', ts('styleCalendar'))\n                .addOption('calendar-sheet', ts('styleCalendarSheet'))\n                .setValue(this.plugin.settings.displayStyle)\n                .onChange(async (value) => {\n                    this.plugin.settings.displayStyle = value as 'commit-graph' | 'calendar' | 'calendar-sheet';\n                    await this.plugin.saveSettings();\n                    this.plugin.updateView();\n                    // Refresh display to show/hide activity dot position setting\n                    this.display();\n                }));\n\n        // Activity Dot Position Setting (only for calendar-sheet)\n        if (this.plugin.settings.displayStyle === 'calendar-sheet') {\n            new Setting(containerEl)\n                .setName(ts('settingActivityDotPosition'))\n                .setDesc(ts('settingActivityDotPositionDesc'))\n                .addDropdown(dropdown => dropdown\n                    .addOption('center', ts('positionCenter'))\n                    .addOption('top-left', ts('positionTopLeft'))\n                    .addOption('top-right', ts('positionTopRight'))\n                    .addOption('bottom-left', ts('positionBottomLeft'))\n                    .addOption('bottom-right', ts('positionBottomRight'))\n                    .setValue(this.plugin.settings.activityDotPosition)\n                    .onChange(async (value) => {\n                        this.plugin.settings.activityDotPosition = value as any;\n                        await this.plugin.saveSettings();\n                        this.plugin.updateView();\n                    }));\n        }\n\n        // First Day of Week Setting\n        new Setting(containerEl)\n            .setName(ts('settingFirstDayOfWeek'))\n            .setDesc(ts('settingFirstDayOfWeekDesc'))\n            .addDropdown(dropdown => dropdown\n                .addOption('0', ts('firstDaySunday'))\n                .addOption('1', ts('firstDayMonday'))\n                .setValue(String(this.plugin.settings.firstDayOfWeek))\n                .onChange(async (value) => {\n                    this.plugin.settings.firstDayOfWeek = parseInt(value) as 0 | 1;\n                    await this.plugin.saveSettings();\n                    this.plugin.updateView();\n                }));\n\n        // Daily Notes Settings Section\n        containerEl.createEl('h3', { text: ts('settingDailyNotes') });\n\n        // Use Daily Notes Plugin Setting\n        const previewPath = await getDailyNotePath(this.app, this.plugin.settings);\n        const useDailyNotesDescFrag = document.createDocumentFragment();\n        useDailyNotesDescFrag.appendText(ts('settingUseDailyNotesPluginDesc'));\n        useDailyNotesDescFrag.createEl('br');\n        useDailyNotesDescFrag.appendText(ts('settingDailyNotesPreviewExample') + ' ');\n        this.pathPreviewSpan = useDailyNotesDescFrag.createEl('span', { \n            text: previewPath, \n            cls: 'u-pop' \n        });\n        \n        new Setting(containerEl)\n            .setName(ts('settingUseDailyNotesPlugin'))\n            .setDesc(useDailyNotesDescFrag)\n            .addToggle(toggle => toggle\n                .setValue(this.plugin.settings.useDailyNotesPlugin)\n                .onChange(async (value) => {\n                    this.plugin.settings.useDailyNotesPlugin = value;\n                    await this.plugin.saveSettings();\n                    this.display();\n                }));\n\n        // Custom Daily Notes Path (only shown when not using plugin settings)\n        if (!this.plugin.settings.useDailyNotesPlugin) {\n            new Setting(containerEl)\n                .setName(ts('settingCustomDailyNotesPath'))\n                .setDesc(ts('settingCustomDailyNotesPathDesc'))\n                .addText(text => text\n                    .setPlaceholder('Daily Notes')\n                    .setValue(this.plugin.settings.customDailyNotesPath)\n                    .onChange(async (value) => {\n                        this.plugin.settings.customDailyNotesPath = value;\n                        await this.plugin.saveSettings();\n                        \n                        // Debounced preview update\n                        if (this.updatePathPreviewDebounce !== null) {\n                            window.clearTimeout(this.updatePathPreviewDebounce);\n                        }\n                        this.updatePathPreviewDebounce = window.setTimeout(() => {\n                            this.updatePathPreview();\n                            this.updateFormatPreview();\n                        }, 300);\n                    }));\n\n            const formatPreviewPath = await getDailyNotePath(this.app, this.plugin.settings);\n            const formatDescFrag = document.createDocumentFragment();\n            formatDescFrag.appendText(ts('settingCustomDailyNotesFormatDesc'));\n            formatDescFrag.createEl('br');\n            formatDescFrag.appendText(ts('settingDailyNotesPreviewExample') + ' ');\n            this.formatPreviewSpan = formatDescFrag.createEl('span', { \n                text: formatPreviewPath, \n                cls: 'u-pop' \n            });\n            \n            new Setting(containerEl)\n                .setName(ts('settingCustomDailyNotesFormat'))\n                .setDesc(formatDescFrag)\n                .addText(text => text\n                    .setPlaceholder('YYYY-MM-DD')\n                    .setValue(this.plugin.settings.customDailyNotesFormat)\n                    .onChange(async (value) => {\n                        this.plugin.settings.customDailyNotesFormat = value;\n                        await this.plugin.saveSettings();\n                        \n                        // Debounced preview update\n                        if (this.updateFormatPreviewDebounce !== null) {\n                            window.clearTimeout(this.updateFormatPreviewDebounce);\n                        }\n                        this.updateFormatPreviewDebounce = window.setTimeout(() => {\n                            this.updatePathPreview();\n                            this.updateFormatPreview();\n                        }, 300);\n                    }));\n        }\n\n        // Period Type Setting\n        new Setting(containerEl)\n            .setName(ts('settingDisplayPeriod'))\n            .setDesc(ts('settingDisplayPeriodDesc'))\n            .addDropdown(dropdown => dropdown\n                .addOption('1month', ts('period1Month'))\n                .addOption('3months', ts('period3Months'))\n                .addOption('6months', ts('period6Months'))\n                .addOption('12months', ts('period12Months'))\n                .addOption('custom', ts('periodCustom'))\n                .setValue(this.plugin.settings.displayPeriod)\n                .onChange(async (value) => {\n                    this.plugin.settings.displayPeriod = value as typeof this.plugin.settings.displayPeriod;\n                    await this.plugin.saveSettings();\n                    this.display();\n                    this.plugin.updateView();\n                }));\n\n        // Custom Date Fields\n        if (this.plugin.settings.displayPeriod === 'custom') {\n            containerEl.createEl('h3', { text: ts('settingCustomDateRange') });\n\n            const startDateSetting = new Setting(containerEl)\n                .setName(ts('settingStartDate'))\n                .setDesc(ts('settingStartDateDesc'));\n            \n            const startDateInput = startDateSetting.controlEl.createEl('input', {\n                type: 'date',\n                cls: 'activity-date-input'\n            });\n            startDateInput.value = this.plugin.settings.customStartDate;\n            startDateInput.addEventListener('change', async (e) => {\n                const target = e.target as HTMLInputElement;\n                this.plugin.settings.customStartDate = target.value;\n                await this.plugin.saveSettings();\n                this.plugin.updateView();\n            });\n\n            const endDateSetting = new Setting(containerEl)\n                .setName(ts('settingEndDate'))\n                .setDesc(ts('settingEndDateDesc'));\n            \n            const endDateInput = endDateSetting.controlEl.createEl('input', {\n                type: 'date',\n                cls: 'activity-date-input'\n            });\n            endDateInput.value = this.plugin.settings.customEndDate;\n            endDateInput.addEventListener('change', async (e) => {\n                const target = e.target as HTMLInputElement;\n                this.plugin.settings.customEndDate = target.value;\n                await this.plugin.saveSettings();\n                this.plugin.updateView();\n            });\n        }\n\n        // Activity Colors Section - Collapsible\n        const colorsSection = containerEl.createEl('details', { cls: 'activity-colors-section' });\n        const colorsSummary = colorsSection.createEl('summary', { cls: 'activity-colors-header' });\n        colorsSummary.createEl('span', { text: ts('settingActivityColors') });\n\n        // Light Theme Colors\n        colorsSection.createEl('h4', { text: ts('settingLightTheme'), cls: 'activity-colors-subheader' });\n        this.renderColorSetting(colorsSection, ts('settingLevel0'), 'lightLevel0');\n        this.renderColorSetting(colorsSection, ts('settingLevel1'), 'lightLevel1');\n        this.renderColorSetting(colorsSection, ts('settingLevel2'), 'lightLevel2');\n        this.renderColorSetting(colorsSection, ts('settingLevel3'), 'lightLevel3');\n        this.renderColorSetting(colorsSection, ts('settingLevel4'), 'lightLevel4');\n\n        // Dark Theme Colors\n        colorsSection.createEl('h4', { text: ts('settingDarkTheme'), cls: 'activity-colors-subheader' });\n        this.renderColorSetting(colorsSection, ts('settingLevel0'), 'darkLevel0');\n        this.renderColorSetting(colorsSection, ts('settingLevel1'), 'darkLevel1');\n        this.renderColorSetting(colorsSection, ts('settingLevel2'), 'darkLevel2');\n        this.renderColorSetting(colorsSection, ts('settingLevel3'), 'darkLevel3');\n        this.renderColorSetting(colorsSection, ts('settingLevel4'), 'darkLevel4');\n\n        // Reset Colors Button\n        new Setting(colorsSection)\n            .setName(ts('settingResetColors'))\n            .setDesc(ts('settingResetColorsDesc'))\n            .addButton(button => button\n                .setButtonText(ts('settingResetButton'))\n                .onClick(async () => {\n                    this.plugin.settings.lightTheme.level0 = '#ebedf0';\n                    this.plugin.settings.lightTheme.level1 = '#9be9a8';\n                    this.plugin.settings.lightTheme.level2 = '#40c463';\n                    this.plugin.settings.lightTheme.level3 = '#30a14e';\n                    this.plugin.settings.lightTheme.level4 = '#216e39';\n                    this.plugin.settings.darkTheme.level0 = '#161b22';\n                    this.plugin.settings.darkTheme.level1 = '#0e4429';\n                    this.plugin.settings.darkTheme.level2 = '#006d32';\n                    this.plugin.settings.darkTheme.level3 = '#26a641';\n                    this.plugin.settings.darkTheme.level4 = '#39d353';\n                    await this.plugin.saveSettings();\n                    this.display();\n                    this.plugin.updateView();\n                }));\n    }\n\n    renderColorSetting(containerEl: HTMLElement, name: string, settingKey: string): void {\n        const setting = new Setting(containerEl)\n            .setName(name);\n        \n        const colorInput = setting.controlEl.createEl('input', {\n            type: 'color',\n            cls: 'activity-color-input'\n        });\n        \n        // Parse settingKey to access nested structure (e.g., \"lightLevel0\" -> lightTheme.level0)\n        const isLight = settingKey.startsWith('light');\n        const levelNum = settingKey.slice(-1);\n        const theme = isLight ? this.plugin.settings.lightTheme : this.plugin.settings.darkTheme;\n        const levelKey = `level${levelNum}` as keyof typeof theme;\n        \n        colorInput.value = theme[levelKey];\n        colorInput.addEventListener('change', async (e) => {\n            const target = e.target as HTMLInputElement;\n            theme[levelKey] = target.value;\n            await this.plugin.saveSettings();\n            this.plugin.updateView();\n        });\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/tasks-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TFile' is defined but never used.","line":1,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DayTasksStatus' is defined but never used.","line":3,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatDailyNoteFilename' is defined but never used.","line":4,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":56},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3317,3320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3317,3320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'settings' is assigned a value but never used.","line":116,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":19}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Vault, TFile } from 'obsidian';\nimport { ActivityData } from './types/ActivityData';\nimport { TasksStatusData, DayTasksStatus } from './types/DayTasksStatus';\nimport { getDailyNotesSettings, formatDailyNoteFilename } from './utils';\n\n/**\n * Extract completed task dates from file content\n */\nfunction extractCompletedTaskDates(content: string): string[] {\n    const dates: string[] = [];\n    const lines = content.split('\\n');\n    \n    for (const line of lines) {\n        if (!/^[\\s]*[-*]\\s*\\[x\\]/i.test(line)) {\n            continue;\n        }\n        \n        // Pattern 1: Tasks plugin format with emoji ✅ YYYY-MM-DD\n        const emojiMatch = line.match(/✅\\s*(\\d{4}-\\d{2}-\\d{2})/);\n        if (emojiMatch) {\n            dates.push(emojiMatch[1]);\n            continue;\n        }\n        \n        // Pattern 2: Dataview format done:: YYYY-MM-DD\n        const dataviewMatch = line.match(/done::\\s*(\\d{4}-\\d{2}-\\d{2})/);\n        if (dataviewMatch) {\n            dates.push(dataviewMatch[1]);\n            continue;\n        }\n        \n        // Pattern 3: completion:: YYYY-MM-DD\n        const completionMatch = line.match(/completion::\\s*(\\d{4}-\\d{2}-\\d{2})/);\n        if (completionMatch) {\n            dates.push(completionMatch[1]);\n            continue;\n        }\n        \n        // Pattern 4: [completion:: YYYY-MM-DD] (inline dataview)\n        const inlineMatch = line.match(/\\[completion::\\s*(\\d{4}-\\d{2}-\\d{2})\\]/);\n        if (inlineMatch) {\n            dates.push(inlineMatch[1]);\n            continue;\n        }\n    }\n    \n    return dates;\n}\n\n/**\n * Load tasks data from all markdown files in vault\n */\nexport async function loadTasksFromVault(vault: Vault): Promise<ActivityData> {\n    const tasksData: ActivityData = {};\n    const files = vault.getMarkdownFiles();\n    \n    for (const file of files) {\n        try {\n            const content = await vault.cachedRead(file);\n            const completedDates = extractCompletedTaskDates(content);\n            \n            for (const date of completedDates) {\n                if (!tasksData[date]) {\n                    tasksData[date] = 0;\n                }\n                tasksData[date]++;\n            }\n        } catch (error) {\n            console.error(`Error reading file ${file.path}:`, error);\n        }\n    }\n    \n    return tasksData;\n}\n\n/**\n * Analyze tasks in a file and return status\n */\nfunction analyzeFileTasks(content: string): { hasCompleted: boolean; hasIncomplete: boolean } {\n    const lines = content.split('\\n');\n    let hasCompleted = false;\n    let hasIncomplete = false;\n    \n    for (const line of lines) {\n        // Check for task markers\n        const isTask = /^[\\s]*[-*]\\s*\\[([ xX])\\]/.test(line);\n        if (!isTask) continue;\n        \n        // Check if completed\n        const isCompleted = /^[\\s]*[-*]\\s*\\[x\\]/i.test(line);\n        \n        if (isCompleted) {\n            hasCompleted = true;\n        } else {\n            hasIncomplete = true;\n        }\n        \n        // Early exit if we found both types\n        if (hasCompleted && hasIncomplete) {\n            break;\n        }\n    }\n    \n    return { hasCompleted, hasIncomplete };\n}\n\n/**\n * Load tasks status for daily notes\n * Returns a map of date -> task status\n */\nexport async function loadTasksStatusFromDailyNotes(\n    vault: Vault,\n    app: any\n): Promise<TasksStatusData> {\n    const statusData: TasksStatusData = {};\n    const settings = getDailyNotesSettings(app);\n    const files = vault.getMarkdownFiles();\n    \n    for (const file of files) {\n        try {\n            // Try to extract date from filename\n            const dateMatch = file.basename.match(/(\\d{4}-\\d{2}-\\d{2})/);\n            if (!dateMatch) continue;\n            \n            const dateStr = dateMatch[1];\n            const content = await vault.cachedRead(file);\n            const { hasCompleted, hasIncomplete } = analyzeFileTasks(content);\n            \n            // Only add if file has tasks\n            if (hasCompleted || hasIncomplete) {\n                statusData[dateStr] = {\n                    hasCompletedTasks: hasCompleted,\n                    hasIncompleteTasks: hasIncomplete\n                };\n            }\n        } catch (error) {\n            console.error(`Error analyzing file ${file.path}:`, error);\n        }\n    }\n    \n    return statusData;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/ActivityData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/ActivityGraphPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/ActivityGraphSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/CalendarDate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/CodeBlockOptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/ColorScheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/DailyNotesSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/DayActivity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/DayTasksStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/LocaleStrings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/RendererOptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/disbro/Main/Projects/obsidian-activity-graph/src/views/activity-graph-view.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
